<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>A SuperCollider Programming Tutorial</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="supercollider-architecture.html"><strong aria-hidden="true">2.</strong> SuperCollider Architecture</a></li><li class="chapter-item expanded "><a href="sclang-quick-reference.html"><strong aria-hidden="true">3.</strong> sclang quick reference</a></li><li class="chapter-item expanded "><a href="composing-in-supercollider.html"><strong aria-hidden="true">4.</strong> Composing in SuperCollider</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">A SuperCollider Programming Tutorial</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This book is a collection of essays, guides, and tips for intermediate to advanced SuperCollider
users.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="supercollider-architecture"><a class="header" href="#supercollider-architecture">SuperCollider architecture</a></h1>
<p>SuperCollider is first and foremost an audio programming language, but there's
a lot more to it than just a textual interface. More specifically,
SuperCollider consists of a audio server architected to support for on-the-fly
definition and reuse of DSP algorithms. Uniquely, the audio is separated from a
client, which provides the actual sequencing and control.</p>
<p>The best way to summarize how SC differs from its peers is that it's not a toy.
It's robust, efficient, and meant to gracefully handle a wide range of sound
synthesis models, no matter how extreme. Design decisions in SC have been made
with these goals in mind. It's not necessarily perfect software, but if didn't
do its job pretty dang well, I wouldn't be here writing this tutorial.</p>
<p>In this chapter, we'll discuss specific details of server-client separation and
how the server works, and explain why they are important. We won't get very
deep into the implementation of SC — just the architecture that you, the user,
have to work with and understand to fully harness the power of the platform.</p>
<h2 id="real-time-audio-constraints"><a class="header" href="#real-time-audio-constraints">Real-time audio constraints</a></h2>
<p>Real-time audio software is under tight time constraints. If a single buffer of
samples takes too long to compute, a horrible glitch is audible. When you're
performing a live work in front of hundreds of people, you generally do not
want your audio to glitch.</p>
<p>Efficiency is a huge concern for audio software that advertises itself as
suitable for real time performance. This is true today, and it was especially
true for computers in 1996. For a lot of software, performance is convenience.
For real-time audio, performance is reliability.</p>
<p>The little CPU meter that you see on many audio programs, SuperCollider
included, is an indicator of how fast DSP is happening. If CPU usage is low and
stable, you can probably rest easy knowing that the program won't glitch out.
If it's seriously fluctuating, you are in trouble.</p>
<p>SuperCollider's server not only needs to be efficient, but it needs to be
flexible. You have to be able to send it arbitrary sound synthesis networks on
the fly, and it has to compile and run those algorithms under real-time
constraints.</p>
<h2 id="server-client-separation"><a class="header" href="#server-client-separation">Server-client separation</a></h2>
<p>In SuperCollider 1 and 2, there was no server-client separation. The language
connected directly to audio driver callbacks, and <em>every</em> operation in the
SuperCollider environment was in the audio thread, where everything must arrive
exactly on time.</p>
<p>This means that not only did UGens have to race against the clock to prevent
glitches, but so did an entire interpreted programming language. Even with a
cleverly written language that had real-time safe garbage collection, there are
some operations that simply cannot be done safely with this scheme — loading a
large sound file from disk would usually cause some kind of glitch, so it would
have to be done before a composition starts.</p>
<p>Modern audio software usually runs separate threads for audio and other non-DSP
(such as graphics). However, back in the 90's, threads were not as powerful and
as widespread on consumer machines.</p>
<p>In SuperCollider 3, the decision was made to split the language and server into
two separate processes. Not only does this allow unsafe operations to be
relegated to one process, but this also keeps a nice separation of concerns
between audio processing and control, allowing for all manner of alternate
clients, alternate servers, multiple clients, multiple servers, and servers
running on a different machine.</p>
<h2 id="the-servers"><a class="header" href="#the-servers">The servers</a></h2>
<p>The SuperCollider server programs are <em>scsynth</em> and <em>supernova</em>. They both do
roughly the same thing. supernova is a newer, ground-up rewrite of scsynth that
adds support for efficient parallel processing on multi-core CPUs, which we'll
discuss later in this chapter.</p>
<p>Both are actively maintained, but supernova is more experimental and buggy due
to its younger age. Furthermore, supernova is not supported on Windows yet, and
was not packaged with the macOS binary build until version 3.10. If you're a
new SC user, scsynth is recommended.</p>
<p>Since scsynth and supernova implement much of the same functionality, I will
use "scsynth" as a shorthand for "scsynth or supernova" throughout these
tutorials.</p>
<h2 id="a-quick-osc-primer"><a class="header" href="#a-quick-osc-primer">A quick OSC primer</a></h2>
<p>The client talks to scsynth and vice versa using Open Sound Control (OSC).
Despite the name, OSC is not very audio-specific at all — it's a lightweight
binary message protocol that lets you send over arrays of common data types.
OSC is usually sent over TCP or UDP.</p>
<p>An OSC message starts with an address, indicated with a forward slash. This is
interpreted as the name of a "command" that the receiver understands. It is
then followed by a heterogeneous array containing any mixture of strings,
floats, integers, binary data, and timestamps.</p>
<p>For example, <code>/s_new</code> is a command that causes scsynth to create a new Synth
node — analogous to a MIDI note on. In sclang, you can send a message to
scsynth using the <code>NetAddr:sendMsg</code> instance method:</p>
<pre><code>Server.default.addr.sendMsg(['/s_new', "piano", -1, 0, "velocity", 0.5]);
</code></pre>
<p>This OSC message tells scsynth to create a new Synth from the <code>piano</code> SynthDef,
setting <code>velocity</code> to 0.5. It is roughly equivalent to</p>
<pre><code>Synth(\piano, [velocity: 0.5])
</code></pre>
<p>There are a few more details like OSC bundles, but we won't go into them yet.
Check the <a href="http://opensoundcontrol.org/">Open Sound Control</a> official website,
which clearly explains the protocol as well as its binary representation.</p>
<h2 id="the-signal-processing-hierarchy-of-scsynth"><a class="header" href="#the-signal-processing-hierarchy-of-scsynth">The signal processing hierarchy of scsynth</a></h2>
<p>A simple real-time modular audio application might have the ability to create
and destroy some pre-fab audio processing nodes on the fly, and functionality
to modulate and rewire them.</p>
<p>It seems nice. Unfortunately, a naive implementation of this formula really
starts to buckle when put under real-world conditions. Musicians want polyphony
— spawning the same synthesis algorithms over and over again from a template
like on a keyboard synthesizer. The ability to efficiently define and reuse DSP
algorithms is a rarely mentioned, but very important area where SC really
shines.</p>
<p>In this section, we'll look at scsynth's unique hierarchical approach to
scaffolding of modular audio processing.</p>
<h3 id="layer-1-signals-and-block-based-processing"><a class="header" href="#layer-1-signals-and-block-based-processing">Layer 1: Signals and block-based processing</a></h3>
<p>Currently, all signals in the server are 32-bit floating-points.</p>
<p>Very importantly, audio signals are processed in blocks, not individual
samples. The size of the block is determined by a command-line option to
scsynth. By default, sclang sets a block size of 64. By processing audio in
blocks, DSP code can take advantage of vectorization and caching to help speed
up computation. However, there is a disadvantage that single-sample feedback
is intractable without making your own UGen in C++. (There <em>is</em> a hack to get
around this using demand-rate UGens, but I won't discuss it here.)</p>
<p>As you might know from the beginner tutorial, SC signals aren't just audio —
some are control-rate signals, conventionally denoted <code>.kr</code> in UGen classes.
These signals define only one sample per block. Performing arithmetic
operations on such signals is significantly faster since there's simply less
signal to deal with. In DSP parlance, control rate signals are "downsampled
processing."</p>
<p>Block-based sample processing is fairly common in well-written audio software,
but marking some signals as audio and others as control is a somewhat SC-unique
deal.</p>
<h3 id="layer-2-ugens-and-units"><a class="header" href="#layer-2-ugens-and-units">Layer 2: UGens and Units</a></h3>
<p>A UGen (unit generator) is a chunk of DSP code, such as an oscillator or filter.
When instantiated, it creates a <em>unit</em>, which is an object that processes input
signals and produces output signals.</p>
<p>In compiled form, UGens physically live in <em>plugins</em>, which are shared
libraries (<code>.scx</code> files on Windows and macOS, <code>.so</code> files on Linux). When
scsynth boots up, it searches for plugin files and loads them. The connective
tissue between scsynth and plugins is known as the <em>plugin interface</em>, a binary
interface written in C.</p>
<h3 id="layer-3-synthdefs-and-synths"><a class="header" href="#layer-3-synthdefs-and-synths">Layer 3: SynthDefs and Synths</a></h3>
<p>A SynthDef is a blueprint describing how UGens are connected together. When
instantiated, the resulting object is a connection of UGens known as a Synth.
Despite the name, a Synth is nowhere close to the physical synthesizer object.
It's a generic, miniature DSP program that can do pretty much anything from
producing sound to processing sound to analyzing it: whatever is possible with
a combination of UGens.</p>
<p>The client can't directly manipulate UGens or units — it has to first create a
SynthDef using <code>/d_recv</code> (<code>SynthDef:add</code>) or related commands, then instantiate
that SynthDef as a Synth using <code>/s_new</code> (<code>Synth.new</code>). To be able to
communicate SynthDefs, SuperCollider defines a binary file format for the
client to write and the server to read. The SynthDef file format is designed to
be very compact: a typical SynthDef may be less than a kilobyte.</p>
<p>SynthDefs can define parameters for the Synths they instantiate and plug them
into UGens like other signals. However, these parameters can only modulate
inputs to UGens — they can't add new UGens, take them away, or rewire the graph
dynamically. It's a bummer sometimes, but it's the price we pay for efficient
and stable modular audio software. Parameters may be directly modulated by the
client using commands such as <code>/n_set</code> (<code>Synth:set</code>).</p>
<p>Synths also talk to the outside world using special UGens — the big ones are
<code>In</code> and <code>Out</code>, which allow reading from and writing from buses. A bus in SC is
a signal, uniquely identified by a global index, which any Synth can write to
or read from. Buses that correspond to hardware inputs and outputs are the most
important.</p>
<p>Once again, we have a class vs. instance distinction between SynthDefs and
Synths. This particular class vs. instance distinction is very musically
important, because it enables efficient polyphony by spawning multiple sound
events from a template. Furthermore, as part of scsynth's aim of real-time
safety, spawning and freeing Synths is a very efficient process. You can easily
fire off hundreds of Synths per second for something like granular synthesis.</p>
<h3 id="layer-4-synth-order-and-groups"><a class="header" href="#layer-4-synth-order-and-groups">Layer 4: Synth order and Groups</a></h3>
<p>As soon as your arrangement of Synths gets complex with multiple Synths writing
to the same buses, order becomes very important. For example, if you have
instrument Synths and a separate Synth for an effect, the effect needs to
process its audio <em>after</em> the instrument. <code>/s_new</code> has a parameter which allows
you to insert the Synth relative to another.</p>
<p>An entirely linear approach to Synth order gets a little bit flimsy the more
complex the order is. Groups offer a solution for robust, hierarchical Synth
order, and the hierarchy formed is known as the "server tree," and the Synths
and Groups within as "nodes."</p>
<p>supernova has a special feature known as a "parallel group" (<code>ParGroup</code>) where
you <em>don't</em> care about order, and instead giving supernova a chance to split
the Synths' workload across different threads. Since many musical applications
involve separate, superimposed sound events that don't interact with each other
(multiple tracks, polyphony), this can result in tremendous CPU improvements
when used properly.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>SuperCollider built unlike pretty much any other audio software out there, but
a lot of its quirky designs are well justified for its goals as an efficient
and flexible sound synthesis platform. The language and server are built from
the ground up for real-time safety, and the <code>SynthDef</code>/<code>Synth</code> distinction
allows for arbitrary polyphony with low overhead.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sclang-quick-reference"><a class="header" href="#sclang-quick-reference">sclang quick reference</a></h1>
<p>sclang is not a hard language to pick up if you're familiar with the likes of JavaScript, Python,
Ruby, or Lua. Its object model and syntax are derived from Smalltalk.</p>
<p>We're just going to breeze through sclang basics here. This isn't meant as a complete language spec,
but just enough information so you can get on comfortable footing for writing programs in SC.</p>
<p>Since I'm showing you around a whole gaddang programming language in this chapter, it's going to get
very long and very dull. As such, this probably isn't the most exciting place to start — the
beginner's guide is much better if you haven't yet written a line of code. But once you start
writing more complex programs and need a quick reference on how to do basic programming tasks, this
is the chapter for you.</p>
<h2 id="sclang-whats-so-special-about-it"><a class="header" href="#sclang-whats-so-special-about-it">sclang: what's so special about it?</a></h2>
<p>Some programmers come to SuperCollider and are understandably highly skeptical of the idea of
learning a new programming language, especially one that was designed in the 90's. And I won't mince
words with you: sclang is far from perfect. It has aged better than some of its contemporaries in
the computer music sphere, but has some really odd design decisions and long-standing limitations.
Due to server-client separation, others have written clients for SC in Scala, Python, Lua, Haskell,
and many other familiar languages. Why should you bother with sclang?</p>
<p>First off, sclang is "soft real-time safe." sclang isn't under the constraints of an audio thread
like scsynth is, but it does need to sequence events with musically accurate rhythm under normal
conditions, so it is written with features like real-time safe garbage collection. Few interpreted
languages are designed with this in mind (Lua is a major one).</p>
<p>Second, sclang has a feature known as multichannel expansion. These three lines are identical:</p>
<pre><code>// Naive way:
[SinOsc.ar(440), SinOsc.ar(660), SinOsc.ar(880)]

// "Don't Repeat Yourself" way, like in most programming languages:
[440, 660, 880].collect { |freq| SinOsc.ar(freq) };

// Best way, using multichannel expansion:
SinOsc.ar([440, 660, 880])
</code></pre>
<p>Most programming languages would at best offer the second syntax. But the third one is true
idiomatic sclang, and it's more terse and elegant. I know you may be thinking that focusing on
syntax is shallow, but this makes a <em>huge</em> difference when actually working on sound synthesis in
your artistic practice.</p>
<p>I'm not claiming that multichannel expansion as implemented in sclang has been executed perfectly,
but it's still tremendously convenient a lot of the time. Being able to duplicate any part of a
sound synthesis graph easily give sclang an advantage over many other programming languages and
graphical dataflow languages.</p>
<p>Finally, if you are a SuperCollider user, you should be aware that sclang is the #1 SuperCollider
client. By only learning an alternate client, you are distancing yourself from the SC community and
limiting your ability to receive or give help. Most SC users are sclang users, and that's a very
important network effect if you're new to the platform.</p>
<p>Don't get me wrong ­— I'm not here to condemn alternate clients and the hard work that goes into
them. I'm sure you'll like some of them better than sclang. But especially for people new to SC,
sclang is strongly recommended.</p>
<h2 id="running-code-in-sclang"><a class="header" href="#running-code-in-sclang">Running code in sclang</a></h2>
<p>For beginning users who come to SC from other languages, the standard method of running code in SC
from the IDE can be pretty weird and offputting. As a refresher, you write SuperCollider code in
<code>.scd</code> files, which have a bunch of code blocks hanging out in space. Rather than running the whole
thing at once, individual lines are run using Shift+Enter, and blocks of code delimited by
parentheses are run using Ctrl+Enter (Cmd+Enter on macOS).</p>
<p>Weird? Yes. But it's less weird once you realize that the <strong>IDE is a glorified REPL</strong>. The workflow
will be familiar if you've ever used Jupyter or an interactive interpreter like Python's. It's just
that REPL is the most common way of interacting with SuperCollider.</p>
<p>It's actually possible — and may be preferable — to run sclang like an ordinary program from the
command line. This can be done by running</p>
<pre><code>sclang my_file.scd
</code></pre>
<p>and it will work fine. The IDE equivalent is to fire up the interpreter, open up <code>my_file.scd</code>, and
select "Language → Evaluate File."</p>
<p>Your file needs to be set up in a special way, however. The parentheses used to delimit code blocks
for interactive execution will not work as expected, and will usually cause syntax errors. The file
should be a single parenthetical block, although without the enclosing parentheses. By default,
sclang does not exit at the end of file evaluation, so you need to manually run, e.g., <code>0.exit</code> to
quit with return code 0. [TODO: provide an actual example!]</p>
<p>Why use REPL in the IDE if sclang can mostly be run as a normal programming language? Although the
workflow is unusual compared to programming environments, it's not without precedent when viewed as
artistic audio software. In your average modular synth software or hardware, the "work interface"
and the "performance interface" are the same. Same for SC: you write your code and you run your code
in the same place. [TODO: clarify]</p>
<p>One obvious reason to use the IDE is if you incorporate live coding into your work — it's a fully
capable live coding interface, and can even be augmented with custom behavior specifically for that
practice. But even if you don't, the IDE provides several user interface benefits, such as showing
you a CPU meter for the server (very important to ensure code is suitable for live performance) and
giving you an easy interface for volume control and recording to disk.</p>
<p>If the whole REPL thing is weird for you, I understand, but I assure you that you will get used to
it. It's all part of SC being live performance software.</p>
<h2 id="comments"><a class="header" href="#comments">Comments</a></h2>
<pre><code class="language-supercollider">// two slashes,

/*
or multiline style.
*/

/* Multiline comments /* DO */ nest. */
</code></pre>
<h2 id="blocks--variables"><a class="header" href="#blocks--variables">Blocks &amp; variables</a></h2>
<p>When you execute code in between parentheses, execute code from a single line,
or execute an entire file, that's a block. The final expression in a block is
its return value. When you execute a block in the IDE, the post window prints
out the block's return value, preceded by a <code>-&gt;</code>.</p>
<pre><code class="language-supercollider">(
1;
2;
3;
)
// -&gt; 3
</code></pre>
<p>You can declare local variables using <code>var</code>. They're lexically scoped, so they
behave similarly to a lot of your favorite languages.</p>
<pre><code class="language-supercollider">(
var foo = 3, bar;
var baz = 50, quux = foo + baz;
quux;
)
// -&gt; 53
</code></pre>
<p>All <code>var</code> statements have to go at the top of the block, and can't be
interspersed with other code. (I know, it sucks.) An unassigned variable is
given a value of <code>nil</code>.</p>
<p>A variable name always starts with a <em>lowercase</em> Latin letter, then any number
of characters in <code>a-z A-Z 0-9 _</code>. The reserved keywords are quite few:</p>
<pre><code>var arg classvar const pi true false nil inf
</code></pre>
<p>These identifiers are valid variable names, but I wouldn't recommend them,
because then you won't have access to the actual builtins in the local scope:</p>
<pre><code>this super thisProcess thisFunction thisFunctionDef thisMethod thisThread
currentEnvironment topEnvironment
</code></pre>
<p>Assigning to variables outside of <code>var</code> statements is done in the regular C way, like <code>foo = 3;</code>.
Assignments return the assigned value, so they may be chained (<code>foo = bar = 3</code>). Operators like <code>+=</code>
are <em>not</em> supported in the spirit of minimalist Smalltalk syntax.</p>
<p>Variables are scoped to the block they are in, and they cease to exist outside of the block. How do
we share information between blocks then?</p>
<h2 id="environment-variables-and-interpreter-globals"><a class="header" href="#environment-variables-and-interpreter-globals">Environment variables and interpreter globals</a></h2>
<p>sclang doesn't have global variables. Instead, sclang has a syntactic feature known as "environment
variables" (not to be confused with the OS-level environment variables like <code>PATH</code>) that provides a
substitute for global scope. These are notated with the <code>~</code> prefix. In casual conversation, SC users
often refer to them as "tilde variables."</p>
<pre><code class="language-supercollider">~foo = 3;
~foo // -&gt; 3
</code></pre>
<p>These variables persist across blocks. However, what they really supply is <em>dynamic scoping</em>. They
are setting and getting key-value data in a global value called <code>currentEnvironment</code>, which can be
manipulated and changed using various instance and class methods of <code>Environment</code>.</p>
<p>Some people like to use exclusively environment variables to get out of typing <code>var</code>. I don't
recommend it. Local variables have garbage collection and are less prone to mistakes (for example, a
typo'd local variable results in a syntax error, while a typo'd tilde variable returns <code>nil</code>). Only
use environment variables when information needs to be passed between interactively executed blocks.</p>
<p>I lied — sclang does actually have global variables, but it has exactly 26 of them: the letters <code>a</code>
through <code>z</code>.</p>
<pre><code class="language-supercollider">x = 3;
x // -&gt; 3
</code></pre>
<p>I strongly advise against using these in any production code. They're okay when you're doing
nonserious tests, but please don't use them in real compositions.</p>
<p>Note that a single-letter variable declared locally (e.g. <code>var x</code>) isn't global, and just behaves
like any other local variable.</p>
<h2 id="method-calls"><a class="header" href="#method-calls">Method calls</a></h2>
<p>In sclang, pretty much every useful operation is performed by doing method calls on objects. The
object we're calling on is referred to as the <em>receiver</em>, and it can take any number of arguments.
The following are the most common syntaxes for method calls:</p>
<pre><code class="language-supercollider">receiver.doSomething(1, 2, 3);
doSomething(receiver, 1, 2, 3);
</code></pre>
<p>The second one looks like a function call, but it's not. <code>doSomething</code> is actually a method name,
and not referring to any variable in the local scope.</p>
<p>Method calls may take keyword arguments:</p>
<pre><code class="language-supercollider">receiver.doSomething(foo: 1, bar: 2, baz: 3);
</code></pre>
<p>If no arguments are provided, the parentheses may be omitted (as they conventionally are):</p>
<pre><code class="language-supercollider">"Hello World".postln();
"Hello World".postln;
</code></pre>
<p>Users coming from JavaScript, Python, or C++ may be used to <code>.</code> being for attribute retrieval in
addition to method calls. In sclang, attribute getters are just method calls.</p>
<h2 id="mathematics"><a class="header" href="#mathematics">Mathematics</a></h2>
<p>I'm sure you can guess what the <code>nil</code>, <code>true</code>, and <code>false</code> keywords are.
Integers (32-bit signed) and floats (64-bit) are notated in pretty obvious
ways:</p>
<pre><code class="language-supercollider">0 -1 1443 0x07 3.0 4.0 1e8 1e-5
</code></pre>
<p>If a decimal point is provided, there must be at least one digit on each side.
Expressions like <code>.5</code> and <code>3.</code> are syntax errors. This avoids some ambiguous
parses.</p>
<p>Your favorite arithmetic operators work as expected. But unlike many other
languages, <strong>infix operator precedence is always left to right</strong>. The order of
operations is not respected. These are identical:</p>
<pre><code class="language-supercollider">3 + 5 * 4
(3 + 5) * 4
</code></pre>
<p>You're probably groaning right now, but it's internally consistent and not unheard of in language
design. One good reason for it is that sclang supports operator overloading, allowing you to define
your own arbitrary operators like <code>@|@&lt;&gt;@|@</code>. How would we define the order of operations for those?</p>
<p>I expect you'll find these operators useful (they are syntactic sugar for method calls):</p>
<pre><code class="language-supercollider">+ - / * ** == != &lt; &gt; &lt;= &gt;=
</code></pre>
<p><code>/</code> always graduates to a float even if both of its arguments are integers. Same for the
exponentiation operator <code>**</code>.</p>
<p><strong>There is no unary <code>-</code></strong>. When you write <code>-1</code>, it's actually a single token. To do unary negation
on variables and other things that aren't numeric literals, use the <code>neg</code> method.</p>
<p>These are good math functions to have under your belt — you can figure them out
easy:</p>
<pre><code class="language-supercollider">asInteger asFloat floor ceil round abs sgn
sin cos tan tanh
</code></pre>
<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<p>Functions are denoted with curly braces. They are first-class objects. The
return value is simply the final line, and the function is called using the
<code>.value</code> method:</p>
<pre><code class="language-supercollider">var myFunction = {
    someOtherObject.doSomething;
    3
};
myFunction.value
// -&gt; 3
</code></pre>
<p><code>myFunction.value</code> can be shortened to <code>myFunction.()</code>, but not <code>myFunction()</code>.</p>
<p>Function arguments are denoted using this funky pipe-delimited section:</p>
<pre><code class="language-supercollider">var myFunction = { |foo, bar, baz = 5|
    foo + bar + baz;
};
myFunction.(3, 4);
// -&gt; 12
</code></pre>
<p>There is an older way of writing this: <code>{ arg foo, bar, baz = 5; ... }</code>, but
it's going out of fashion.</p>
<p>Like in JavaScript, functions not strict about variable arguments. Unspecified
arguments with no explicit default value are set to <code>nil</code>. If too many
arguments are provided, they are simply ignored.</p>
<h2 id="conditionals"><a class="header" href="#conditionals">Conditionals</a></h2>
<p>Boolean operators in sclang are a little different from other languages.</p>
<pre><code class="language-supercollider">(0 == 1).not  // -&gt; false

// Equivalent:
true.and(false)
true and: false

// The second is known as "key binary operator" syntax, and can be used in the
// special case where only one argument is passed to the method.

// 'and' and 'or' require their second argument to be wrapped in a function
// for short circuiting to occur:
doThisThing.() or: { doThatThing.() }
</code></pre>
<p>In keeping with sclang's minimal syntax, control structures are just method
calls involving functions.</p>
<pre><code class="language-supercollider">(
if(2 + 2 == 4, {
    "Nice!".postln;
}, {
    "What?".postln;
});
)

// Shortcut syntax that may be used because all arguments are functions.

(
if(2 + 2 == 4) {
    "Nice!".postln;
} {
    "What?".postln;
};
)

// 'if' produces a return value from the function/block that was run, so it
// actually doubles as a ternary operator.
if(2 + 2 == 4, { "Nice" }, { "What" }).postln;

// 'case' is a quick way to write a bunch of nested 'if's. The first condition
// that's true is evaluated.
case
    { x &lt; 0 } { "It's negative".postln; }
    { x &gt; 1000 } { "It's nonnegative, but too big".postln; }
    { x % 2 == 0 } { "It's an even number".postln; };

// 'switch' is very similar to ordinary switch statements. Like 'if' and
// 'case', it passes along the return value of the function that was actually
// evaluated.
switch(thing,
    \option1, { "Option 1" },
    \option2, { "Option 2" }
).postln;

// You can wrap the values in functions — saves a few commas.
switch(thing)
    { \option1 } { "Option 1".postln }
    { \option2 } { "Option 2".postln };
</code></pre>
<p>sclang is strict about only Booleans being placed in <code>if</code>, <code>not</code>, <code>and</code>, and
<code>or</code>. If you try something like <code>if(0, ...)</code>, you will receive an error that
says "Non Boolean in test."</p>
<p><code>if</code>, <code>switch</code>, and <code>case</code> are <em>not</em> keywords. They are methods.</p>
<h2 id="arrays"><a class="header" href="#arrays">Arrays</a></h2>
<p>Creation, getting, and setting are the usual. Zero-indexed.</p>
<pre><code class="language-supercollider">(
var myArray = [1, 3, 4, 4, 3];
myArray[0] = myArray[3];
myArray[1] = "hey";
"Array size is %".format(myArray.size).postln;
myArray;
)
// Array size is 5
// -&gt; [ 4, hey, 4, 4, 3 ]

// NOTE: getting and setting indices are actually syntactic sugar for the ".at"
// and ".put" methods.
</code></pre>
<p>Retrieving an out-of-bounds index returns <code>nil</code>. Setting an out-of-bounds index produces an error.</p>
<p>Here are a few useful ways to create arrays:</p>
<pre><code class="language-supercollider">(0..4)    // -&gt; [ 0, 1, 2, 3, 4 ], inclusive of both endpoints
(1,3..10) // -&gt; [ 1, 3, 5, 7, 9 ]
4.dup(8)  // -&gt; [ 4, 4, 4, 4, 4, 4, 4, 4 ]
{ |i| i ** 2 }.dup(8)   // -&gt; [ 0, 1, 4, 9, 16, 25, 36, 49 ]
</code></pre>
<p>sclang supports multichannel expansion. Binary and unary operators, when
applied to arrays, are broadcast to the array's elements:</p>
<pre><code class="language-supercolliders">[1, 2, 3, 4] + 4   // -&gt; [ 5, 6, 7, 8 ]
[3, 4, 5] * [1, 6, 8]  // -&gt; [ 3, 24, 40 ]
</code></pre>
<p>This sounds small, but it becomes unbelievably convenient when working with
multichannel sound design.</p>
<p>Appending to arrays is done using the <code>.add</code> method. However, for efficiency
<strong><code>.add</code> may or may not be in place</strong>. To avoid unexpected behavior, always
assign the return value of <code>.add</code> back to the slot for the original array:</p>
<pre><code class="language-supercollider">(
var myArray = [1, 2, 3];
myArray = myArray.add(4);
)
// -&gt; [1, 2, 3, 4]
</code></pre>
<p>Slices are denoted with <code>..</code> and are inclusive of both indices:</p>
<pre><code class="language-supercollider">(
var myArray = [1, 5, 2, 0, 4, 4];
myArray[2..4]
)
// -&gt; [ 2, 0, 4 ]
</code></pre>
<p>The following tools are also useful — I am certain you can figure out how they work from their names
and very brief examples, and if not, you can consult the documentation:</p>
<pre><code class="language-supercollider">["con", "cat"] ++ ["en", "a", "tion"]
newArray = array.copy
array.indexOf(thing)
array.includes(thing)
["heads", "tails"].choose
array.scramble
</code></pre>
<h2 id="iteration"><a class="header" href="#iteration">Iteration</a></h2>
<p>sclang has a rich variety of methods for iterating and filtering arrays. Here is a very terse
summary of them.</p>
<pre><code class="language-supercollider">// Prints numbers 0 through 7 inclusive.
8.do { |i| "i".postln; };

// Remember, 8.do { ... } is just shorthand for 8.do({ ... }).

// Do something for each element. index is optional.
array.do { |elem| ... };
array.do { |elem, index| ... };

// Do something for each element and make a new array from the return values.
// Often called "map" in other environments
var newArray = array.collect { |elem| ... };

// Filter the array and keep only elements for which the given function returns
// true. The function should only return Booleans.
var newArray = array.select { |elem| elem % 2 == 0 };

// Return true iff the function returns true for any/every element.
// The function should only return Booleans.
[1, 2, 3].any { |elem| elem % 2 == 0 }
[1, 2, 3].every { |elem| elem % 2 == 0 }
</code></pre>
<p>These methods don't lazy evaluate on arrays, so chaining them isn't efficient like in functional
programming environments. SC does have native coroutines via the <code>Routine</code> class.</p>
<p>Array methods get the job done most of the time, but <code>while</code> loops are also sometimes necessary:</p>
<pre><code>var x = 3;
while { x &lt; 10 } {
    x.postln;
    x = x + 1;
};

// More idiomatic: (3..9).do { |x| x.postln }
</code></pre>
<p>Loops can be broken out of using the <code>block</code> method, which is exceedingly rare but occasionally
the best option:</p>
<pre><code>block { |break|
    5.do { |i|
        if(i &gt; 3) {
            break.value("hey"); // "hey" is the return value of block { ... }
        };
    };
};
</code></pre>
<h2 id="strings-and-symbols"><a class="header" href="#strings-and-symbols">Strings and symbols</a></h2>
<pre><code class="language-supercollider">"Strings are delimited with double quotes."
"Strings can be
multiline."
"Escape characters: \t \f \v \n \r \\"
</code></pre>
<p>sclang will tolerate non-ASCII bytes in strings, but they are just bytes, and Unicode isn't really
understood. The SCIDE displays UTF-8, so if you're careful, non-ASCII characters will come out
unscathed. Sorry about that.</p>
<p>Strings are effectively immutable arrays of <code>Char</code> objects. <code>Char</code> objects have a literal syntax:
<code>$a</code>.</p>
<p>Symbols are similar to strings, but are efficient when reused, and not so efficient for textual
operations. A symbol is therefore ideal for identifiers that are only meaningful within your
program, while a string is intended for actual text input, manipulation, and output.</p>
<pre><code class="language-supercollider">'Symbols are delimited by single quotes'

// But if the symbol is a valid identifier, there's a much simpler syntax:
\validIdentifier2000
</code></pre>
<p>Here are some useful things to do with strings and symbols — any ambiguities can be cleared up by
consulting the docs:</p>
<pre><code class="language-supercollider">// Querying:
"string".size

// Conversion:
"string".asSymbol
\symbol.asString
3.asString
"3".asInteger
"3".asFloat

// Modification:
"concaten" ++ "ation"
"with" + "space" + "in" + "between"
"path/" +/+ "/joining"
"You can format %.".format("strings")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="composing-in-supercollider"><a class="header" href="#composing-in-supercollider">Composing in SuperCollider</a></h1>
<p>It’s easy to write code in SC that sounds great for around 10 seconds, but immediately tires itself out. SuperCollider users from beginners to experts have long struggled with the question: how do I turn sound design patches into complete works of music with a beginning, middle, and end?</p>
<p>SC being a programming language, the options are limitless and there’s no specific attempt to impose a workflow on you. But like all music software, it isn’t neutral. When incorporating SC into a compositional practice, the strengths and weaknesses of the SC interface need to be taken into account.</p>
<p>Here are some ideas on how you can incorporate SC into a compositional practice. Probably the most important point before we proceed: <em>you don't need to constrain yourself to make your piece entirely in SC</em>. Many people use it as just one layer in a larger mix.</p>
<h2 id="live-interaction"><a class="header" href="#live-interaction">Live interaction</a></h2>
<p>SC particularly excels one thing: live interaction. Even if you only plan on making fixed-media works, don't discount the option of using real-time interaction in your process. It is totally okay to make a live patch and record yourself using it. The live element doesn't need to become a performance -- it can just be part of your compositional workflow.</p>
<p>One obvious one is to use a MIDI controller with SC. Large-scale compositional form can be created by turning knobs and pressing buttons.</p>
<p>Or you can make a GUI in sclang, and use that as a live interface.</p>
<p>Or you can analyze microphone input and use analysis parameters to modulate parameters of your patch.</p>
<p>Or you can use other hardware interfaces. Hook up sensors via Arduino and SerialPort. On a laptop, you can also make use of the mouse, keyboard, webcam, and accelerometer.</p>
<p>Or you can run blocks of code live -- even if you aren’t interested in live coding as a performance practice, this is often a very easy way to create section transitions.</p>
<h2 id="sequencing-in-sclang"><a class="header" href="#sequencing-in-sclang">Sequencing in sclang</a></h2>
<p>Also be aware of SC's major weakness: note entry via arrays is really, really awkward. I don't recommend typing in melodies with Pbind unless they're very simple.</p>
<p>If you're composing music with relatively traditional notions of melody and harmony, you might want to look into using SC as a MIDI synthesizer rather than a compositional interface. Try composing MIDI in a DAW, routing the MIDI to SuperCollider, and routing SuperCollider's audio output back into the DAW. (Or, of course, hook up a MIDI keyboard and play it, but I already mentioned that.)</p>
<p>There are also specialized score programs such as IanniX and OSSIA that work great with large-scale sequencing in SC. Alternatively, depending on your needs, you could build a timeline view in SC's GUI features -- although that sounds like a ton of work to me.</p>
<p>You can also embrace text-based entry if you like it. One easy way to get sequencing in SC is to write a parser for a domain-specific language for entering notes, drum patterns, etc. I have programmed drum patterns using single characters like this: "k.k. s.th thkk s.t.". Try developing your own personalized sequencer notation that specifically fits your musical practice.</p>
<p>If your piece evolves slowly, you can also use a Routine and schedule when certain synths stop and start. This is a good choice for drone and ambient music.</p>
<p>Unsurprisingly, the SC environment is great for algorithmically generated melody, harmony, and rhythm, which could replace ordinary sequencing.</p>
<h2 id="other-ideas"><a class="header" href="#other-ideas">Other ideas</a></h2>
<p>Use SC as an effect on an instrument.</p>
<p>Make a patch in SC and record yourself messing around with parameters. Use a DAW to sample your favorite parts and assemble them into a piece.</p>
<p>Design individual note sounds in SC. Record them and load them into a sampler. Use it in a larger work.</p>
<h2 id="conclusions"><a class="header" href="#conclusions">Conclusions</a></h2>
<p>Unlike a lot of other music software, SC has a very open workflow and finding the best process is a matter of exploration.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
