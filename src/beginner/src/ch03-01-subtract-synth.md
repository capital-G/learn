# Simple Subtractive Synthesis

In this chapter we're going to show you how to make a simple subtractive synthesizer. For a lot of
musicians this is what they mean when they mean a synthesizer. In their heads they will think of
maybe a Moog synthesizer, with a nice low pass filter and some simple envelopes. While SuperCollider
can do a lot more than this, subtractive synthesis is certainly possible.

## What is Subtractive Synthesis

If you already know how subtractive synthesis works then feel free to skip this section. In this
section we're just going to give a high level description of what subtractive synthesis is, and how
you use it.

TODO:
+ Types of oscillator and their wave forms
+ Low pass filter
+ Envelope
+ For amplitude
+ For filters
+ High Pass Filter

Should probably be reasonably graphical - and would be good to have sound samples here as well.

## Hello Synth

So let's build a really simple synthesizer with a single oscillator:

```
(SynthDef(\HelloSynth,
  {
    Out.ar(0, SinOsc.ar(440));
}).add);
```

Evaluate this block. Now let's play this synth:

```
Synth(\HelloSynth)
```

Hopefully you should now hear a simple test tone on your left speaker.

When you get sick of it you can stop the synth by pressing ```ctrl-.``` on Windows/Linux, or
```cmd-.``` on OSX.

So what is going on here?  In our first bit of code SynthDef defines a synth template imaginatively
called ```HelloSynth```. This doesn't create a synth, or make any sound on the server. Instead it
provides a template that can be used for creating synths. The way way we create a synth is by a call
to ```Synth```, passing in the name of our synth template.

NOTE: When we name a synth, or a template, we preceed the name with a backslash: '\'. A user defined
label preceeded by a backslash is called a symbol. Here are some examples of a symbol:
+ ```\MySymbol```
+ ```BestSynth```

You may remember that we used symbols previously when we were looking at ```Pbind```. There a symbol
was used as a key, and this is also a common thing you will see in SuperCollider. Don't worry if
this isn't superclear - as you see more examples this will become clearer.

In the ```SynthDef``` everything surrounded by ```{``` and ```}``` is the synth definition. The
diagram below shows you the block structure for this synth definition:

[DIAGRAM]

Out.ar pipes the sound generated by the synth to the audio SuperCollider infrastructure. If you're
familiar with modular synthesis - if you think of the synth as a module, then Out.ar is the output
from the module (if you're not familiar don't worry, hopefully things will become clearer shortly).

```Out.ar``` takes two parameters:
+ **Audio bus number** - In this case bus number 0.
+ **Sound source** - In this case the output from the SinOscillator.

If we change the `bus number` the output will go somewhere else. If you change `0` above to `1` you
should now hear the test 

So what are defining in the ```SynthDef```? 

## Oscillations all Around

In the previous


## A Playable Synth

So far our synth doesn't do much

## Building a Simple Moog Synth

Fair warning - this won't sound enormously like a Moog, but the principles are the same.

```
```

## A little bit more analog

Let's face it, true analog synths have a little bit more grit than this. Fortunately SuperCollider
does have one filter which sounds characteristically dirty: ```DFM1```.

So let's plug it into our synth below.

+ mention that it takes resonance, rather than Q
+ input gain will overdrive it (demonstrate that with a pattern)
+ Noiselevel can also make it sound noisier if that's something you want.
+ Finally, can also use it as a high pass filter.


## Limitations of SuperCollider

Currently SuperCollider does not have really nice analog modelled filters beyond DFM1 (which you
saw above). There are some filters which do sound *more* analog:

+ **RLPFD** - A 909 emulation
+ Moog filters (need to make a recommendation about which is the best) - these are reasonable for
high frequencies, but won't give you the characteristic Moog *growl* at low frequencies.

This is a recognized limitation currently and is something that is being worked on - but for the
moment if you really want good analog modelling then soft synths (or hardware) are the way to go. As
you'll see in a later chapter SuperCollider can interface quite nicely using MIDI, so all is not
lost.